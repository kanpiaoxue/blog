#SEDA架构
###发表时间：2015-06-02
###分类：java,SEDA
###iteye原始地址：<a href="https://kanpiaoxue.iteye.com/admin/blogs/2216453" target="_blank">https://kanpiaoxue.iteye.com/admin/blogs/2216453</a>

---

<div class="iteye-blog-content-contain" style="font-size: 14px;"> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong>纯粹转发，没有深入研究，转自：</strong></span><a id="viewpost1_TitleUrl" class="singleposttitle" style="color: #223355; font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 12px; font-weight: bold; line-height: 24.5454540252686px;" href="http://www.blogjava.net/killme2008/archive/2010/06/20/324022.html" target="_blank">SEDA架构笔记</a></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong>&nbsp;</strong></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong>一、传统并发模型的缺点</strong></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;">基于线程的并发</span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><img style="border-style: none; max-width: 100%;" src="http://img.my.csdn.net/uploads/201211/08/1352369094_2910.png" alt=""><br></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">特点：</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">每任务一线程</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">直线式的编程</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">使用资源昂高，</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">context切换代价高，竞争锁昂贵</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">太多线程可能导致吞吐量下降，响应时间暴涨。</span><br></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;</span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">基于事件的并发模型</span><br></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><img style="border-style: none; max-width: 100%;" src="http://img.my.csdn.net/uploads/201211/08/1352369098_5733.png" alt=""><br></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">特点：</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">单线程处理事件</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">每个并发流实现为一个有限状态机</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">应用直接控制并发</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">负载增加的时候，吞吐量饱和</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">响应时间线性增长</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><br></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong>二、SEDA架构</strong></span><br></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong><img style="border-style: none; max-width: 100%;" src="http://img.my.csdn.net/uploads/201211/08/1352369102_4613.png" alt=""><br></strong></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">特点：</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">(1)服务通过queue分解成stage:</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; 每个stage代表FSM的一个状态集合</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; Queue引入了控制边界</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">(2)使用线程池驱动stage的运行:</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; 将事件处理同线程的创建和调度分离</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; Stage可以顺序或者并行执行</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; Stage可能在内部阻塞，给阻塞的stage分配较少的线程</span><br></strong></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">1、Stage-可靠构建的基础</span><br></strong></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong><img style="border-style: none; max-width: 100%;" src="http://img.my.csdn.net/uploads/201211/08/1352369105_6820.png" alt=""><br></strong></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-weight: bold;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">(1)应用逻辑封装到Event Handler</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; 接收到许多事件，处理这些事件，然后派发事件加入其他Stage的queue</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; 对queue和threads没有直接控制</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; Event queue吸纳过量的负载，有限的线程池维持并发</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">(2)Stage控制器</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp; 负责资源的分配和调度</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp; 控制派发给Event Handler的事件的数量和顺序</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp; Event Handler可能在内部丢弃、过滤、重排序事件。</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><br>2、应用=Stage网络</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; (1)有限队列&nbsp;</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 入队可能失败，如果队列拒绝新项的话</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 阻塞在满溢的队列上来实现吸纳压力</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过丢弃事件来降低负载</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; (2) 队列将Stage的执行分解</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 引入了显式的控制边界</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 提供了隔离、模块化、独立的负载管理</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; (3)方便调试和profile</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 事件的投递可显</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 时间流可跟踪</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 通过监测queue的长度发现系统瓶颈</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">3、动态资源控制器</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><br>(1)、线程池管理器</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">目标： 决定Stage合理的并发程度</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">操作：</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">观察queue长度，如果超过阀值就添加线程</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">移除空闲线程</span><br></span></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-weight: bold;"><img style="border-style: none; max-width: 100%;" src="http://img.my.csdn.net/uploads/201211/08/1352369109_7636.png" alt=""><br></span></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-weight: bold;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">(2)、批量管理器</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">目的：低响应时间和高吞吐量的调度</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">操作：</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">Batching因子：Stage一次处理的消息数量</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">小的batching因子：低响应时间</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">大的batching因子：高吞吐量</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">尝试找到具有稳定吞吐量的最小的batching因子</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">观察stage的事件流出率</span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">当吞吐量高的时候降低batching因子，低的时候增加</span><br></span></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-weight: bold;"><img style="border-style: none; max-width: 100%;" src="http://img.my.csdn.net/uploads/201211/08/1352369113_5739.png" alt=""><br></span></span></span></span></span></p> 
 <p style="color: #333333; font-family: Arial; line-height: 26px;"><span style="font-family: Verdana, Geneva, Arial, Helvetica, sans-serif; font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-weight: bold;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><strong>三、小结</strong></span><br style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;"><span style="font-size: 16.3636360168457px; line-height: 24.5454540252686px;">&nbsp;&nbsp; SEDA主要还是为了解决传统并发模型的缺点，通过将服务器的处理划分各个Stage，利用queue连接起来形成一个pipeline的处理链，并且在Stage中利用控制器进行资源的调控。资源的调度依据运行时的状态监视的数据来进行，从而形成一种反应控制的机制，而stage的划分也简化了编程，并且通过queue和每个stage的线程池来分担高并发请求并保持吞吐量和响应时间的平衡。简单来说，我看中的是服务器模型的清晰划分以及反应控制。</span></span></span></span></span></span></p> 
</div>